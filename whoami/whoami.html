<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultimate Client Info</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
body { font-family: Arial, sans-serif; background: #f0f0f0; color: #333; padding: 30px; }
h1 { text-align: center; margin-bottom: 20px; }
.info { background: #fff; padding: 20px; margin: 0 auto 20px auto; border-radius: 8px; max-width: 950px; box-shadow: 0 0 10px rgba(0,0,0,0.1); white-space: pre-wrap; }
#map { height: 400px; max-width: 950px; margin: 0 auto; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
.controls { max-width: 950px; margin: 0 auto 16px auto; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
button.action { padding: 10px 14px; border: none; border-radius: 6px; background: #333; color: #fff; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
button.action:disabled { opacity: 0.6; cursor: not-allowed; }
.info h2 { margin-top: 0; }
.info .kv { display: grid; grid-template-columns: 220px 1fr; gap: 8px 12px; }
.info .kv div { overflow-wrap: anywhere; }
.info hr { border: none; border-top: 1px solid #eee; margin: 16px 0; }
.badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #eee; font-size: 12px; margin-left: 6px; }
.ok { background: #d1fae5; }
.warn { background: #fde68a; }
.err { background: #fecaca; }
.small { font-size: 12px; color: #666; }
</style>
</head>
<body>
<h1>Ultimate Client Information</h1>
<div class="controls">
  <button id="copyBtn" class="action">Copy JSON</button>
  <button id="downloadBtn" class="action">Download JSON</button>
  <button id="permBtn" class="action">Request Key Permissions</button>
  <button id="geoBtn" class="action">Request Precise Location</button>
</div>
<div class="info" id="clientInfo">Loading client information...</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
// Utility: safe JSON stringify for circular/BigInt
function safeStringify(obj){
  const seen = new WeakSet();
  return JSON.stringify(obj, (k,v)=>{
    if (typeof v === 'bigint') return v.toString();
    if (typeof v === 'object' && v !== null){
      if (seen.has(v)) return '[Circular]';
      seen.add(v);
    }
    return v;
  }, 2);
}

async function getPermission(name, opts){
  if (!('permissions' in navigator) || !navigator.permissions.query) return {state:'unsupported'};
  try { const res = await navigator.permissions.query(Object.assign({name}, opts||{})); return {state: res.state}; } catch(e){ return {state:'error'}; }
}

function parseUA(ua){
  try {
    const data = navigator.userAgentData?.toJSON?.() || null;
    return {raw: ua, brands: data?.brands || null, mobile: data?.mobile ?? null, platform: data?.platform || navigator.platform};
  } catch { return {raw: ua}; }
}

function testWebSocket(url='wss://echo.websocket.events'){
  return new Promise(resolve=>{
    try{
      const ws = new WebSocket(url);
      const timer = setTimeout(()=>{ try{ws.close();}catch{}; resolve({ok:false, error:'timeout'}); }, 6000);
      ws.onopen = ()=>{ try{ ws.send('ping'); }catch{} };
      ws.onmessage = ()=>{ clearTimeout(timer); try{ws.close();}catch{}; resolve({ok:true}); };
      ws.onerror = ()=>{ clearTimeout(timer); resolve({ok:false, error:'error'}); };
      ws.onclose = ()=>{};
    }catch(e){ resolve({ok:false, error: e.message}); }
  });
}

function getLocalIPs(){
  // Best-effort; modern browsers may only expose mDNS hostnames
  return new Promise(resolve=>{
    const ips = new Set();
    try{
      const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
      pc.createDataChannel('x');
      pc.onicecandidate = (e)=>{
        if (e && e.candidate && e.candidate.candidate){
          const c = e.candidate.candidate;
          const m = c.match(/candidate:.*? (udp|tcp) (\d+) (\S+) (\S+)/);
          // Extract the IP/host at the end
          const parts = c.split(' ');
          const host = parts[4] || '';
          if (host) ips.add(host);
        } else if (!e || !e.candidate){
          resolve(Array.from(ips));
        }
      };
      pc.createOffer().then(of=>pc.setLocalDescription(of));
      setTimeout(()=>{ try{pc.close();}catch{}; resolve(Array.from(ips)); }, 7000);
    }catch{ resolve([]); }
  });
}

async function getStorageEstimate(){
  try{
    if (navigator.storage && navigator.storage.estimate){
      const est = await navigator.storage.estimate();
      return {quota: est.quota || null, usage: est.usage || null, usageDetails: est.usageDetails || null};
    }
  }catch{}
  return {quota:null, usage:null};
}

function getPerf(){
  const nav = performance.getEntriesByType('navigation')[0];
  const mem = performance.memory || null; // Chrome only
  return {
    navigation: nav ? {
      type: nav.type,
      startTime: nav.startTime,
      duration: nav.duration,
      domContentLoaded: nav.domContentLoadedEventEnd - nav.startTime,
      loadEventEnd: nav.loadEventEnd - nav.startTime,
      transferSize: nav.transferSize,
      encodedBodySize: nav.encodedBodySize,
      decodedBodySize: nav.decodedBodySize,
    } : null,
    memory: mem ? {
      jsHeapSizeLimit: mem.jsHeapSizeLimit,
      totalJSHeapSize: mem.totalJSHeapSize,
      usedJSHeapSize: mem.usedJSHeapSize,
    } : null
  };
}

async function getUltimateClientInfo() {
  const infoDiv = document.getElementById('clientInfo');
  const copyBtn = document.getElementById('copyBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const permBtn = document.getElementById('permBtn');
  const geoBtn = document.getElementById('geoBtn');

  let map, ipMarker, gpsMarker;

  const ua = navigator.userAgent;
  const uaParsed = parseUA(ua);

  // Browser & System
  const browser = ua;
  const platform = navigator.platform;
  const language = navigator.language;
  const vendor = navigator.vendor;
  const engine = navigator.product;
  const isSecure = window.isSecureContext;
  const protocol = location.protocol;
  const online = navigator.onLine;

  // Screen & Device
  const screenRes = `${window.screen.width}x${window.screen.height}`;
  const viewport = `${window.innerWidth}x${window.innerHeight}`;
  const colorDepth = window.screen.colorDepth;
  const pixelRatio = window.devicePixelRatio || 1;
  const orientationType = (screen.orientation || {}).type || 'Unknown';
  const touchSupport = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

  // Storage & Plugins
  const cookiesEnabled = navigator.cookieEnabled;
  const localStorageEnabled = (() => { try { localStorage.setItem('x','1'); localStorage.removeItem('x'); return true; } catch { return false; }})();
  const sessionStorageEnabled = (() => { try { sessionStorage.setItem('x','1'); sessionStorage.removeItem('x'); return true; } catch { return false; }})();
  const indexedDBSupport = !!window.indexedDB;
  const cacheSupport = 'caches' in window;
  const plugins = Array.from(navigator.plugins || []).map(p => p.name);

  // Fonts (basic heuristic)
  const fonts = ['Arial','Courier New','Georgia','Times New Roman','Verdana'];
  const availableFonts = fonts.filter(f => {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    context.font = '72px monospace';
    const baseline = context.measureText('mmmmmmmmmm').width;
    context.font = `72px ${f}, monospace`;
    return context.measureText('mmmmmmmmmm').width !== baseline;
  });

  // Canvas fingerprint sample
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.textBaseline = 'top';
  ctx.font = "14px 'Arial'";
  ctx.fillStyle = '#f60';
  ctx.fillRect(125,1,62,20);
  ctx.fillStyle = '#069';
  ctx.fillText('Fingerprint Test', 2, 15);
  const canvasFingerprint = (()=>{ try { return canvas.toDataURL(); } catch { return 'blocked'; }})();

  // WebGL/GPU Info
  let gpuVendor = 'Unknown', gpuRenderer = 'Unknown';
  try {
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    const debugInfo = gl && gl.getExtension('WEBGL_debug_renderer_info');
    if (gl && debugInfo){
      gpuVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
      gpuRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
    }
  } catch(e){}

  // Battery & Connection
  let batteryLevel = 'Unknown', batteryCharging = 'Unknown';
  try { const b = await navigator.getBattery(); batteryLevel = b.level; batteryCharging = b.charging; } catch(e){}
  const connection = navigator.connection || {};

  // Media devices
  let mediaDevices = [];
  try { mediaDevices = await navigator.mediaDevices.enumerateDevices(); } catch(e) {}
  const hasCamera = mediaDevices.some(d => d.kind === 'videoinput');
  const hasMicrophone = mediaDevices.some(d => d.kind === 'audioinput');

  // Camera & microphone permissions to infer resolution/sample rate (no stream capture by default)
  let cameraRes = 'Unknown', micRate = 'Unknown';
  try {
    const permCam = await getPermission('camera');
    const permMic = await getPermission('microphone');
    if (permCam.state === 'granted' || permMic.state === 'granted'){
      const stream = await navigator.mediaDevices.getUserMedia({video: permCam.state==='granted', audio: permMic.state==='granted'});
      const videoTrack = stream.getVideoTracks()[0];
      if(videoTrack) cameraRes = `${videoTrack.getSettings().width}x${videoTrack.getSettings().height}`;
      const audioTrack = stream.getAudioTracks()[0];
      if(audioTrack) micRate = audioTrack.getSettings().sampleRate || 'Unknown';
      stream.getTracks().forEach(t => t.stop());
    }
  } catch(e){}

  // Public IP & Geo
  let ip = 'Unknown', city = 'Unknown', country = 'Unknown', org = 'Unknown', latitude = null, longitude = null;
  try {
    const resp = await fetch('https://ipapi.co/json/');
    const data = await resp.json();
    ip = data.ip; city = data.city; country = data.country_name; org = data.org; latitude = data.latitude; longitude = data.longitude;
  } catch(e){}

  // Try precise geolocation if already granted
  let accuracy = null, altitude = null, speed = null, heading = null;
  try {
    const perm = await getPermission('geolocation');
    if (perm.state === 'granted'){
      await new Promise(resolve => {
        navigator.geolocation.getCurrentPosition(pos => {
          latitude = pos.coords.latitude;
          longitude = pos.coords.longitude;
          accuracy = pos.coords.accuracy;
          altitude = pos.coords.altitude;
          speed = pos.coords.speed;
          heading = pos.coords.heading;
          resolve();
        }, () => resolve(), {enableHighAccuracy:true, maximumAge: 10000, timeout: 8000});
      });
    }
  } catch(e){}

  // Device Orientation & Motion (single-sample best-effort)
  let orientationData = {alpha:null, beta:null, gamma:null};
  let motionData = {x:null, y:null, z:null, acceleration:null, rotationRate:null};
  try {
    window.addEventListener('deviceorientation', e => {
      orientationData.alpha = e.alpha; orientationData.beta = e.beta; orientationData.gamma = e.gamma;
    }, {once:true});
    window.addEventListener('devicemotion', e => {
      motionData.x = e.accelerationIncludingGravity?.x;
      motionData.y = e.accelerationIncludingGravity?.y;
      motionData.z = e.accelerationIncludingGravity?.z;
      motionData.acceleration = e.acceleration || null;
      motionData.rotationRate = e.rotationRate || null;
    }, {once:true});
  } catch(e){}

  // Ambient Light Sensor (rarely supported)
  let ambientLight = 'Unknown';
  try {
    if('AmbientLightSensor' in window){
      const sensor = new AmbientLightSensor();
      sensor.onreading = () => { ambientLight = sensor.illuminance; };
      sensor.start();
      setTimeout(()=>{ try{sensor.stop();}catch{} }, 5000);
    }
  } catch(e){}

  // Service Worker Support & MIME Types
  const serviceWorkers = 'serviceWorker' in navigator;
  const mimeTypes = (navigator.mimeTypes && Array.from(navigator.mimeTypes).map(m=>m.type)) || [];

  // Time
  const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const systemTime = new Date().toString();

  // Permissions Snapshot
  const permissions = {
    geolocation: await getPermission('geolocation'),
    camera: await getPermission('camera'),
    microphone: await getPermission('microphone'),
    notifications: await getPermission('notifications'),
    clipboardRead: await getPermission('clipboard-read'),
    clipboardWrite: await getPermission('clipboard-write'),
    midi: await getPermission('midi', {sysex:false}),
    accelerometer: await getPermission('accelerometer'),
    gyroscope: await getPermission('gyroscope'),
    magnetometer: await getPermission('magnetometer'),
    persistentStorage: await getPermission('persistent-storage')
  };

  // Storage estimate
  const storage = await getStorageEstimate();

  // WebSocket test
  const ws = await testWebSocket();

  // Local IPs (best effort)
  const localIPs = await getLocalIPs();

  // Performance
  const perf = getPerf();

  // Aggregate report
  const report = {
    meta: { collectedAt: new Date().toISOString(), isSecure, protocol, online },
    browser: { ...uaParsed, vendor, engine, language },
    display: { screenRes, viewport, colorDepth, pixelRatio, orientationType },
    input: { touchSupport },
    storage: { cookiesEnabled, localStorageEnabled, sessionStorageEnabled, indexedDBSupport, cacheSupport, estimate: storage },
    plugins,
    fonts: availableFonts,
    canvasFingerprint,
    graphics: { gpuVendor, gpuRenderer },
    power: { batteryLevel, batteryCharging },
    network: {
      connection: {
        type: connection.effectiveType || 'Unknown',
        downlink: connection.downlink || null,
        rtt: connection.rtt || null,
        saveData: connection.saveData || false
      },
      websocket: ws,
      publicIP: { ip, org, city, country },
      localIPs
    },
    media: { hasCamera, hasMicrophone, cameraRes, micRate },
    location: { latitude, longitude, accuracy, altitude, speed, heading },
    sensors: { orientationData, motionData, ambientLight },
    features: { serviceWorkers, mimeTypes },
    time: { timezone, systemTime },
    permissions,
    performance: perf
  };

  // Render UI
  function badge(state){
    if (!state) return '';
    const cls = state==='granted' ? 'ok' : state==='denied' ? 'err' : state==='prompt' ? 'warn' : '';
    return `<span class="badge ${cls}">${state}</span>`;
  }

  infoDiv.innerHTML = `
  <h2>Overview</h2>
  <div class="kv">
    <div>Protocol</div><div>${protocol} ${isSecure ? '<span class="badge ok">secure</span>' : '<span class="badge err">insecure</span>'}</div>
    <div>Online</div><div>${online}</div>
    <div>Timezone</div><div>${timezone}</div>
    <div>System Time</div><div>${systemTime}</div>
  </div>
  <hr/>
  <h2>Browser & System</h2>
  <div class="kv">
    <div>User Agent</div><div>${browser}</div>
    <div>Platform</div><div>${platform}</div>
    <div>Vendor</div><div>${vendor}</div>
    <div>Engine</div><div>${engine}</div>
    <div>Language</div><div>${language}</div>
    <div>UserAgentData</div><div>${safeStringify(uaParsed)}</div>
  </div>
  <hr/>
  <h2>Display & Input</h2>
  <div class="kv">
    <div>Screen</div><div>${screenRes}</div>
    <div>Viewport</div><div>${viewport}</div>
    <div>Color Depth</div><div>${colorDepth}</div>
    <div>Pixel Ratio</div><div>${pixelRatio}</div>
    <div>Orientation</div><div>${orientationType}</div>
    <div>Touch Support</div><div>${touchSupport}</div>
  </div>
  <hr/>
  <h2>Storage & Features</h2>
  <div class="kv">
    <div>Cookies Enabled</div><div>${cookiesEnabled}</div>
    <div>LocalStorage</div><div>${localStorageEnabled}</div>
    <div>SessionStorage</div><div>${sessionStorageEnabled}</div>
    <div>IndexedDB</div><div>${indexedDBSupport}</div>
    <div>Cache API</div><div>${cacheSupport}</div>
    <div>Estimate</div><div>${safeStringify(storage)}</div>
    <div>Plugins</div><div>${plugins.join(', ') || 'None'}</div>
    <div>Detected Fonts</div><div>${availableFonts.join(', ') || 'None'}</div>
  </div>
  <hr/>
  <h2>Graphics</h2>
  <div class="kv">
    <div>GPU Vendor</div><div>${gpuVendor}</div>
    <div>GPU Renderer</div><div>${gpuRenderer}</div>
    <div>Canvas Fingerprint</div><div class="small">${canvasFingerprint.substring(0,60)}...</div>
  </div>
  <hr/>
  <h2>Network</h2>
  <div class="kv">
    <div>Conn. Type</div><div>${report.network.connection.type}</div>
    <div>Downlink</div><div>${report.network.connection.downlink || 'Unknown'} Mbps</div>
    <div>RTT</div><div>${report.network.connection.rtt || 'Unknown'} ms</div>
    <div>Save-Data</div><div>${report.network.connection.saveData}</div>
    <div>WebSocket</div><div>${ws.ok ? '<span class="badge ok">ok</span>' : `<span class="badge err">${ws.error||'fail'}</span>`}</div>
    <div>Public IP</div><div>${ip} (${org || 'Unknown'})</div>
    <div>Geo (IP)</div><div>${city}, ${country}</div>
    <div>Local IPs</div><div>${(localIPs && localIPs.length) ? localIPs.join(', ') : 'Unknown/Restricted'}</div>
  </div>
  <hr/>
  <h2>Media</h2>
  <div class="kv">
    <div>Camera</div><div>${hasCamera}</div>
    <div>Camera Resolution</div><div>${cameraRes}</div>
    <div>Microphone</div><div>${hasMicrophone}</div>
    <div>Microphone Sample Rate</div><div>${micRate}</div>
  </div>
  <hr/>
  <h2>Location & Sensors</h2>
  <div class="kv">
    <div>Latitude</div><div>${latitude}</div>
    <div>Longitude</div><div>${longitude}</div>
    <div>Accuracy</div><div>${accuracy}</div>
    <div>Altitude</div><div>${altitude}</div>
    <div>Speed</div><div>${speed}</div>
    <div>Heading</div><div>${heading}</div>
    <div>Orientation (α,β,γ)</div><div>${orientationData.alpha}, ${orientationData.beta}, ${orientationData.gamma}</div>
    <div>Motion X/Y/Z</div><div>${motionData.x}, ${motionData.y}, ${motionData.z}</div>
    <div>Ambient Light</div><div>${ambientLight}</div>
  </div>
  <hr/>
  <h2>Permissions</h2>
  <div class="kv">
    <div>Geolocation</div><div>${badge(permissions.geolocation.state)}</div>
    <div>Camera</div><div>${badge(permissions.camera.state)}</div>
    <div>Microphone</div><div>${badge(permissions.microphone.state)}</div>
    <div>Notifications</div><div>${badge(permissions.notifications.state)}</div>
    <div>Clipboard Read</div><div>${badge(permissions.clipboardRead.state)}</div>
    <div>Clipboard Write</div><div>${badge(permissions.clipboardWrite.state)}</div>
    <div>Accelerometer</div><div>${badge(permissions.accelerometer.state)}</div>
    <div>Gyroscope</div><div>${badge(permissions.gyroscope.state)}</div>
    <div>Magnetometer</div><div>${badge(permissions.magnetometer.state)}</div>
    <div>Persistent Storage</div><div>${badge(permissions.persistentStorage.state)}</div>
  </div>
  <hr/>
  <h2>Performance</h2>
  <div class="kv">
    <div>Nav Entry</div><div>${perf.navigation ? safeStringify(perf.navigation) : 'N/A'}</div>
    <div>Memory</div><div>${perf.memory ? safeStringify(perf.memory) : 'N/A'}</div>
  </div>
  `;

  // Map rendering: show IP-based and precise (if different) markers
  if (latitude && longitude){
    map = L.map('map').setView([latitude, longitude], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    ipMarker = L.marker([latitude, longitude]).addTo(map).bindPopup(`${city}, ${country} (from IP)`);
  }

  // Hook up buttons
  const dataBlob = new Blob([safeStringify(report)], {type:'application/json'});
  const dlUrl = URL.createObjectURL(dataBlob);

  copyBtn.onclick = async ()=>{
    try { await navigator.clipboard.writeText(safeStringify(report)); copyBtn.textContent = 'Copied!'; setTimeout(()=>copyBtn.textContent='Copy JSON', 1500); }
    catch { copyBtn.textContent = 'Copy failed'; setTimeout(()=>copyBtn.textContent='Copy JSON', 1500); }
  };

  downloadBtn.onclick = ()=>{
    const a = document.createElement('a');
    a.href = dlUrl; a.download = 'client-info.json'; a.click();
  };

  permBtn.onclick = async ()=>{
    try {
      // Request notifications permission if available
      if (window.Notification && Notification.requestPermission) await Notification.requestPermission();
      // Request persistent storage if supported
      if (navigator.storage && navigator.storage.persist) { try{ await navigator.storage.persist(); }catch{} }
      // Request camera/mic (will prompt)
      try{ const s = await navigator.mediaDevices.getUserMedia({video:true, audio:true}); s.getTracks().forEach(t=>t.stop()); }catch{}
      // Update page after prompts
      getUltimateClientInfo();
    } catch{}
  };

  geoBtn.onclick = async ()=>{
    try {
      await new Promise(resolve => {
        navigator.geolocation.getCurrentPosition(pos => {
          const {latitude: lat, longitude: lng} = pos.coords;
          if (!map){
            map = L.map('map').setView([lat, lng], 12);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
          }
          if (gpsMarker) { map.removeLayer(gpsMarker); }
          gpsMarker = L.marker([lat, lng]).addTo(map).bindPopup('Precise GPS');
          map.setView([lat, lng], 12);
          resolve();
        }, ()=> resolve(), {enableHighAccuracy:true, maximumAge: 5000, timeout: 8000});
      });
    } catch{}
  };
}

getUltimateClientInfo();
</script>
</body>
</html>
